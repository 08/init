#!/bin/bash
# Copyright (c) 2013 The CoreOS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

set -e -o pipefail

if [[ -z "${USER}" || "${USER}" == root ]]; then
    UPDATE_USER="core"
else
    UPDATE_USER="${USER}"
fi

USAGE="Usage: $0 [-l] [-u user] [-a name file1... | -d name]
Options:
    -u USER     Update the given user's authorized_key's file [${UPDATE_USER}]
    -a NAME     Add the given keys, using the given name to identify them.
    -d NAME     Delete keys identified by the given name.
    -l          List the names and number of keys currently installed.
    -h          This ;-)

This tool provides a consistent way for different systems to add ssh public
keys to a given user account, usually the default '${UPDATE_USER}' user.
The -a and -d options are mutually exclusive. If neither are provided the
authorized_keys file is simply regenerated using the existing keys.

With the -a option keys may be provided as files on the command line. If no
files are provided with the -a option the keys will be read from stdin.
"

ADD_NAME=""
DEL_NAME=""
LIST_ALL=0

while getopts "lu:a:d:h" OPTION
do
    case $OPTION in
        l) LIST_ALL=1 ;;
        u) UPDATE_USER="$OPTARG" ;;
        a) ADD_NAME="$OPTARG" ;;
        d) DEL_NAME="$OPTARG" ;;
        h) echo "$USAGE"; exit;;
        *) exit 1;;
    esac
done

shift $(( OPTIND - 1 ))

if [[ -n "${ADD_NAME}" && -n "${DEL_NAME}" ]]; then
    echo "$0: The -a and -d options cannot be combined." >&2
    exit 1
fi

UPDATE_GROUP=$(id -ng "${UPDATE_USER}")
UPDATE_HOME=$(getent passwd "${UPDATE_USER}" | cut -d: -f6)
if [[ -z "${UPDATE_HOME}" ]]; then
    echo "$0: ${UPDATE_USER}: unknown home directory" >&2
    exit 1
elif [[ ! -d "${UPDATE_HOME}" ]]; then
    echo "$0: ${UPDATE_HOME}: home directory is not a directory"
    exit 1
fi

# Check for an alternate path for testing
SSH_DIR="${_TEST_SSH_PATH:-${UPDATE_HOME}/.ssh}"

# Everything we do should be user-access only!
umask 077

# If this is the first time this script has run we don't want to wipe out
# any existing keys, someone might not like unexpectedly loosing access.
KEYS_DIR="${SSH_DIR}/authorized_keys.d"
if [[ ! -d "${KEYS_DIR}" ]]; then
    mkdir -p "${KEYS_DIR}"
    if [[ -f "${SSH_DIR}/authorized_keys" ]]; then
        cp -a "${SSH_DIR}/authorized_keys" \
            "${KEYS_DIR}/old_authorized_keys"
    fi
fi

# Make sure .ssh is sane
chown "${UPDATE_USER}:${UPDATE_GROUP}" "${SSH_DIR}" "${KEYS_DIR}"

if [[ -n "$ADD_NAME" ]]; then
    keyfile=$(mktemp "${KEYS_DIR}/${ADD_NAME}.XXXXXXXXXX")
    trap "rm -f '${keyfile}'" EXIT
    chown "${UPDATE_USER}:${UPDATE_GROUP}" "${keyfile}"
    cat "$@" > "${keyfile}"
    echo "Adding/updating $ADD_NAME:"
    ssh-keygen -l -f "${keyfile}"
    mv "${keyfile}" "${KEYS_DIR}/${ADD_NAME}"
    trap - EXIT
elif [[ -n "$DEL_NAME" ]]; then
    if [[ ! -f "${KEYS_DIR}/${DEL_NAME}" ]]; then
        echo "$0: no key set named ${DEL_NAME} found for ${UPDATE_USER}" >&2
        exit 1
    else
        echo "Removing ${DEL_NAME}:"
        ssh-keygen -l -f "${KEYS_DIR}/${DEL_NAME}" || true
        rm "${KEYS_DIR}/${DEL_NAME}"
    fi
fi

if [[ "$(ls "${KEYS_DIR}")" ]]; then
    if [[ ${LIST_ALL} -eq 1 ]]; then
        echo "All keys for ${UPDATE_USER}:"
        for keyfile in "${KEYS_DIR}/"*; do
            echo "${keyfile##*/}:"
            ssh-keygen -l -f "${keyfile}"
        done
    fi
    allkeys=$(mktemp "${SSH_DIR}/authorized_keys.XXXXXXXXXX")
    trap "rm -f '${allkeys}'" EXIT
    chown "${UPDATE_USER}:${UPDATE_GROUP}" "${allkeys}"
    echo "# auto-generated by $0" > "${allkeys}"
    cat "${KEYS_DIR}/"* >> "${allkeys}"
    mv "${allkeys}" "${SSH_DIR}/authorized_keys"
    echo "Updated ${SSH_DIR}/authorized_keys"
else
    # The user may delete the last key authorized_keys.d but we won't touch
    # authorized_keys after that, they are on their own at that point.
    echo "$0: no keys found in ${KEYS_DIR}" >&2
    exit 1
fi
